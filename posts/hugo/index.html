<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<title>vnord/posts/hugo/</title>
<meta name=description content="master of many vnords">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="all,follow">
<meta name=googlebot content="index,follow,snippet,archive">
<link rel=stylesheet href=https://vnord.net/hugo-theme-console/css/terminal-0.7.1.min.css>
<link rel=stylesheet href=https://vnord.net/hugo-theme-console/css/animate-3.7.2.min.css>
<link rel=stylesheet href=https://vnord.net/hugo-theme-console/css/console.css>
<link rel=stylesheet href=https://vnord.net/css/custom.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]-->
<meta property="og:title" content="Hello CD">
<meta property="og:description" content="Simplifying my blogging work flow with Hugo, Sinatra, and Webhooks.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://vnord.net/posts/hugo/"><meta property="article:published_time" content="2021-03-05T00:00:00+00:00">
<meta property="og:site_name" content="vnord">
<meta name=twitter:title content="Hello CD">
<meta name=twitter:description content="Simplifying my blogging work flow with Hugo, Sinatra, and Webhooks.">
</head>
<body class=terminal>
<div class=container>
<div class=terminal-nav>
<header class=terminal-logo>
<div class="logo terminal-prompt">
<a href=https://vnord.net/ class=no-style>vnord</a>:~#
<a href=https://vnord.net/posts>posts</a>/<a href=https://vnord.net/posts/hugo>hugo</a>/</div></header>
<nav class=terminal-menu>
<ul vocab="https://schema.org/" typeof="BreadcrumbList">
<li><a href=https://vnord.net/posts/ typeof="ListItem">posts/</a></li>
<li><a href=https://vnord.net/cv.pdf typeof="ListItem">cv/</a></li>
</ul>
</nav>
</div>
</div>
<div class=container>
<h1>Hello CD</h1>
Mar. 5, 2021
<br><br>
<p><em>Author&rsquo;s note on 2022-10-04: this post is kinda dumb, see <a href=../hugo-2>this post</a>.</em></p>
<h1 id=prelude-hakyll>Prelude: Hakyll</h1>
<p>This website has (as far as I can remember) always been statically generated.
I&rsquo;ve tried various static site generators &ndash; mainly Jekyll, and its cousin
Hakyll, which I liked for the terrible reason that it&rsquo;s written in Haskell and
functional programming is of course cool.</p>
<p>Well, I got it into my head that I wanted to write more blog posts (like this
one). The problem is that I get this into my head every now and then, but
usually the moments are so far in-between that in the meantime my development
environment has been wiped several times, or I&rsquo;m using a different computer, or
whatever. And setting up Hakyll every time is&mldr; well, not exactly pleasant.
Haskell&rsquo;s <code>stack</code> may be an excellent tool, but it does leave some things to be
desired. More on that in a moment.</p>
<p>So the solution would be to introduce some kind of continuous deployment &ndash; as
soon as I write a new blog post in markdown and push it to Github, it should be
built somewhere and pushed to my web server. Simple enough &ndash; or so I thought.</p>
<p>The first thing I tried was to set up an environment where the Github
repository could be cloned, and Hakyll could then generate the static files. I
had two alternatives here: either do it on the web server itself, or do it on
my general-purpose home-server Raspberry Pi (gen 4). I suspected I might have
to go for the latter, even though it would introduce another link in the chain
(and thus potential headaches whenever it goes down or I move or whatever). But
running Hakyll on my web server was actually not entirely implausible &ndash; it
turns out that my host, NearlyFreeSpeech, actually does have a <code>ghc</code> binary and
even <code>cabal-install</code>. But actually building Hakyll with <code>cabal install hakyll</code>
didn&rsquo;t work out &ndash; it seems that the build of one of the dependencies required
too much memory or something (I didn&rsquo;t bother spending too much time on
figuring out if there was a way around this). And <code>stack</code> does not work on
FreeBSD (which is what my web server uses), so that was also out of the
question.</p>
<p>So I ended up giving up on running Hakyll on my web server. The next thing I
tried was to install Hakyll on my Raspberry Pi. This might very well have
worked, but I <code>ctrl-c</code>&rsquo;d the stack build in frustration after a couple of hours
of building dependencies. I didn&rsquo;t want my pi to be an additional part of the
deploy chain anyway.</p>
<h1 id=hugo>Hugo</h1>
<p>So I decided to switch from Hakyll to Hugo after seeing the <a href=https://themes.gohugo.io/anatole/>very nice
theme</a> that I am currently using. It did
need some minor modifications in order to please my aesthetic sensibilities, so
I created a new Github repository for my Hugo site, forked the theme, and added
it as a submodule. I then brought over most of my old markdown posts which only
needed slight modifications in order to work with the new system.</p>
<p>So far, so good! It looked like Hugo could replace Hakyll. Now I just needed
to set up the deployment which was so cumbersome with Hakyll.</p>
<p>It turns out that NearlyFreeSpeech already provide a <code>hugo</code> binary, so the
first step was easier than pie. Just clone my repository and its submodule, and
run</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>hugo --minify -d /home/public/
</code></pre></div><p>and voilÃ , we have a website!</p>
<h1 id=deployment>Deployment</h1>
<p>At this stage, I would would have to <code>ssh</code> into my web server every time I make
an update, and pull in the changes before executing the above command. Better
than what I did before (which involved <code>scp</code> ðŸ˜°), but not exactly
ezpz.</p>
<p>So the next step is to automate that process. It turns out that Github has a
nifty webhooks feature that can send HTTP requests whenever something happens
in a repository. In this case we&rsquo;re only interested in the default case, which
is a <code>push</code> to the repository. So when that happens, you can configure Github
to fire off a <code>POST</code> at an arbitrary URL.</p>
<p>So the deploy chain would look something like this:</p>
<ol>
<li>I make changes to my website (e.g. write a new post like this one).</li>
<li>I push the changes to Github.</li>
<li>Github sends a <code>POST</code> request to my web server.</li>
<li>My web server receives the request and fires off a deployment script that
pulls in the changes and then executes <code>hugo</code> to generate the static site
and populate my website.</li>
</ol>
<p>There are a few questions that need to be resolved here. Who was web server,
and when where he when Github was <code>POST</code>s? (If you&rsquo;re too old to parse that,
it&rsquo;s a variant of a <a href=https://knowyourmeme.com/memes/john-is-kill>meme</a>). How
do we make sure my server doesn&rsquo;t get DDOS:ed if someone sends a bunch of
<code>POST</code>s to the correct URL on my web server? How do we actually fire off the
deployment script?</p>
<p>So my initial random internet searches turned up a few snippets that seemed
related to what I wanted to do. The payload that Github posts to your server
can be configured to be encrypted with a secret, that you then decrypt it with
in order to verify that it is indeed Github that is phone. I found a PHP
snippet which seemed to do exactly this. After verifying that the request does
indeed look good, it would then fire off the deploy script with</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=nx>exec</span><span class=p>(</span><span class=s1>&#39;/path/to/my/deploy_script.sh&#39;</span><span class=p>);</span>
</code></pre></div><p>So just put the modified
<a href=https://gist.github.com/cferdinandi/e6e4e05c4b25e322db4eb1f1998523ac>snippet</a>
in a file called <code>deploy.php</code> in my <code>public</code> folder, and everything should just
work, right? Wrong.</p>
<p>The script certainly seemed to do something. It would log its actions to a
file, so it was certainly running. It needed some cajoling to even get to the
right <code>if</code> branch at first, though. I had to get the secret Github token into
the environment somehow (I couldn&rsquo;t put it in <code>deploy.php</code>, of course, as
that&rsquo;s readable by anyone) &ndash; <code>SetEnv SECRET_TOKEN "random_secret_string_here"</code>
in <code>.htaccess</code> seemed to be the best bet. Then, for some reason
<code>getenv('SECRET_TOKEN')</code> only turned up an empty string, but
<code>$_ENV['SECRET_TOKEN']</code> worked as expected. After getting <code>deploy.php</code> to
receive the <code>POST</code> requests and decrypt them as expected, the only thing left
to figure out was why <em>NOTHING WAS HAPPENNING</em>.</p>
<p>For some mysterious reason, everything except executing things seemed to work.
This seemed to be related to Apache running the PHP script as the user <code>web</code>,
which lacks a lot of privileges. I tried a lot of things &ndash; I set the
permissions everywhere in different combinations and with different owners and
sticky bits for various folders, files, and scripts. I tried invoking the shell
script via a CGI script. I tried typing my commands in a more aggressive manner
in order to convince my web server that this indeed was serious business. I
eventually gave up and decided to try a different approach.</p>
<h1 id=sinatra>Sinatra</h1>
<p>Github&rsquo;s <a href=https://docs.github.com/en/developers/webhooks-and-events/webhooks>webhooks
documentation</a>
contained some Ruby snippets, and references to something called
<a href=http://sinatrarb.com/>Sinatra</a> &ndash; which is &ldquo;a DSL for quickly creating web
applications in Ruby with minimal effort&rdquo;. What&rsquo;s not to like? But how in the
world would this work together with Apache?</p>
<p>Luckily, I was able to find a <a href=https://github.com/clpo13/SinatraNFSN>Github
repository</a> with the code and
instructions needed to do almost exactly what I wanted &ndash; set up a Sinatra app
to run on a lightweight webserver (called Thin), and <em>on my particular web
host, NearlyFreeSpeech</em>. Bingo! All I needed to do was change my server realm
to one that supported daemons, then run my Sinatra app as a daemon on its own
port and set up a proxy so that my deploy URL would point at that port. Bingo!</p>
<p>And that was it. Invoking my deploy script in Ruby worked exactly as expected,
and decrypting the payload was a piece of cake.</p>
<p>Fin.</p>
<div class=footer>
</div>
</div>
</body>
</html>